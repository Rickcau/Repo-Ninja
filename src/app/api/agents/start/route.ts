import { NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { createTask, updateTask } from "@/lib/agent-store";
import {
  getOctokit,
  getRepoTree,
  listRepoIssues,
  createBranch,
  commitFiles,
  createPullRequest,
} from "@/lib/github/octokit";
import { ChromaDBStore } from "@/lib/chromadb/chromadb-store";
import { askCopilot } from "@/lib/copilot-sdk/client";
import { buildIssueSolverPrompt } from "@/lib/copilot-sdk/prompts";
import type { AgentTaskType } from "@/lib/types";

interface StartRequest {
  type: AgentTaskType;
  repo: string;
  description: string;
  issueNumber?: number;
}

export async function POST(request: Request) {
  const session = await getServerSession(authOptions);
  if (!session?.accessToken) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const body = (await request.json()) as StartRequest;
  const { type, repo, description, issueNumber } = body;

  if (!type || !repo || !description) {
    return NextResponse.json(
      { error: "type, repo, and description are required" },
      { status: 400 }
    );
  }

  const [owner, repoName] = repo.split("/");
  if (!owner || !repoName) {
    return NextResponse.json(
      { error: "repo must be in owner/repo format" },
      { status: 400 }
    );
  }

  // Create the task in the store
  const task = createTask(type, repo, description);
  updateTask(task.id, { status: "running", progressMessage: "Task started" });

  try {
    const octokit = getOctokit(session.accessToken);

    // Fetch repo context
    updateTask(task.id, { progressMessage: "Fetching repository context..." });
    const tree = await getRepoTree(octokit, owner, repoName, "HEAD");
    const repoContext = tree.slice(0, 100).join("\n");

    // Get issue details if solving an issue
    let issueTitle = description;
    let issueBody = "";
    if (type === "issue-solver" && issueNumber) {
      updateTask(task.id, { progressMessage: `Fetching issue #${issueNumber}...` });
      const issues = await listRepoIssues(octokit, owner, repoName);
      const issue = issues.find((i) => i.number === issueNumber);
      if (issue) {
        issueTitle = issue.title;
        issueBody = issue.body;
      }
    }

    // Query ChromaDB for agent instructions
    updateTask(task.id, { progressMessage: "Querying knowledge base..." });
    const store = new ChromaDBStore();
    const knowledgeDocs = await store.search(
      type === "issue-solver" ? "agent instructions issue solving" : "agent instructions code writing",
      5
    );

    // Build prompt and invoke Copilot
    updateTask(task.id, { progressMessage: "Invoking Copilot for code generation..." });
    const prompt =
      type === "issue-solver"
        ? buildIssueSolverPrompt(issueTitle, issueBody, repoContext, knowledgeDocs)
        : buildCodeWriterPrompt(description, repoContext, knowledgeDocs);

    const response = await askCopilot(prompt);

    // Parse the response
    let parsed: {
      summary: string;
      files: Array<{ path: string; content: string }>;
      commitMessage: string;
    };

    try {
      // Try to extract JSON from the response (may have markdown code fences)
      const jsonMatch = response.match(/\{[\s\S]*\}/);
      parsed = JSON.parse(jsonMatch?.[0] || response);
    } catch {
      // If parsing fails, create a simple result
      updateTask(task.id, {
        status: "failed",
        progressMessage: "Failed to parse Copilot response",
        result: { summary: "Failed to parse Copilot response" },
      });
      return NextResponse.json({ task: updateTask(task.id, {}) });
    }

    // Create branch
    const branchName = `repo-ninja/${type}/${task.id}`;
    updateTask(task.id, {
      branch: branchName,
      progressMessage: `Creating branch ${branchName}...`,
    });
    await createBranch(octokit, owner, repoName, branchName, "HEAD");

    // Commit files
    if (parsed.files && parsed.files.length > 0) {
      updateTask(task.id, { progressMessage: "Committing files..." });
      await commitFiles(
        octokit,
        owner,
        repoName,
        branchName,
        parsed.files,
        parsed.commitMessage || `feat: ${description}`
      );
    }

    // Create pull request
    updateTask(task.id, { progressMessage: "Creating pull request..." });
    const pr = await createPullRequest(
      octokit,
      owner,
      repoName,
      parsed.commitMessage || `[Repo-Ninja] ${description}`,
      `## Automated by Repo-Ninja\n\n${parsed.summary}\n\n---\nGenerated by Repo-Ninja Agent (${type})`,
      branchName,
      "main"
    );

    // Update task as completed
    const finalTask = updateTask(task.id, {
      status: "completed",
      prUrl: pr.htmlUrl,
      progressMessage: "Pull request created successfully",
      result: {
        summary: parsed.summary,
        prUrl: pr.htmlUrl,
      },
    });

    return NextResponse.json({ task: finalTask });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    const failedTask = updateTask(task.id, {
      status: "failed",
      progressMessage: `Error: ${message}`,
      result: { summary: `Task failed: ${message}` },
    });
    return NextResponse.json({ task: failedTask }, { status: 500 });
  }
}

/**
 * Build a prompt for the code-writer agent type.
 */
function buildCodeWriterPrompt(
  description: string,
  repoContext: string,
  knowledgeDocs: { id: string; content: string; metadata: { filename: string } }[]
): string {
  const context = knowledgeDocs
    .map((doc) => `--- ${doc.metadata.filename} ---\n${doc.content}`)
    .join("\n\n");

  return `You are Repo-Ninja, an expert developer. Write code based on the following request and standards:

${context}

Request: ${description}

Repository context:
${repoContext}

Generate the code changes needed. For each file, provide the complete content.
Respond as JSON:
{
  "summary": "Brief description of changes",
  "files": [
    { "path": "src/example.ts", "action": "create", "content": "full file content..." }
  ],
  "commitMessage": "feat: description of changes"
}

Be specific about file paths and follow existing patterns in the repository.`;
}
