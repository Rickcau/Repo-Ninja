# Authentication and Authorization Patterns

## Purpose

This checklist guides code reviewers on authentication and authorization security patterns. Use it to evaluate whether a pull request implements auth correctly, follows industry best practices, and avoids common vulnerabilities that lead to unauthorized access or data breaches.

## Authentication Patterns

- [ ] JWT tokens include only necessary claims and do not contain sensitive data (passwords, PII)
- [ ] JWT signature algorithm is explicitly set (RS256 or ES256 preferred over HS256 for distributed systems)
- [ ] JWT expiration (`exp`) is set to a short duration (15 minutes or less for access tokens)
- [ ] Session-based auth uses server-side session stores (Redis, database) rather than in-memory stores
- [ ] Session IDs are regenerated after successful authentication to prevent session fixation
- [ ] OAuth 2.0 flows use the Authorization Code grant with PKCE for public clients
- [ ] OAuth state parameter is validated to prevent CSRF during the authorization flow
- [ ] OAuth redirect URIs are validated against a strict allowlist (no open redirects)
- [ ] Authentication endpoints enforce rate limiting to prevent brute-force attacks

## Secure Password Storage

- [ ] Passwords are hashed with bcrypt (cost factor 12+) or Argon2id before storage
- [ ] Plaintext passwords are never logged, cached, or stored in any form
- [ ] Password hashing occurs server-side only (client-side hashing is not a substitute)
- [ ] Salt is unique per password and generated by the hashing library (not manually managed)
- [ ] Password strength requirements are enforced (minimum length, breach database checks)
- [ ] Legacy hashing algorithms (MD5, SHA-1, SHA-256 without salt) are flagged for migration

## Token Handling Best Practices

- [ ] Access tokens are stored in memory or HttpOnly cookies (never in localStorage or sessionStorage)
- [ ] Refresh tokens are stored in HttpOnly, Secure, SameSite=Strict cookies
- [ ] Refresh tokens are rotated on each use and previous tokens are invalidated
- [ ] Token revocation is supported (blacklist or database check for critical operations)
- [ ] Expired tokens are rejected immediately -- no grace period without explicit justification
- [ ] Token scope is limited to the minimum required permissions
- [ ] Tokens are transmitted only over HTTPS and never included in URLs or query parameters

## Authorization Patterns

- [ ] Authorization checks occur on every request at the server layer (not only in the UI)
- [ ] Role-Based Access Control (RBAC) roles are defined centrally, not scattered across endpoints
- [ ] Attribute-Based Access Control (ABAC) policies are evaluated consistently through a policy engine
- [ ] Claims-based authorization validates claims from trusted token issuers only
- [ ] Resource-level authorization verifies the caller owns or has access to the specific resource
- [ ] Permission changes take effect immediately (no stale permission caching)
- [ ] Default access is deny-all -- permissions are granted explicitly, not by omission
- [ ] Administrative actions are logged with the acting user, timestamp, and affected resource

## Common Auth Vulnerabilities

- [ ] No credentials or tokens are hardcoded in source code, configuration files, or comments
- [ ] Authentication bypass is not possible by manipulating request headers or parameters
- [ ] Password reset tokens are single-use, time-limited, and tied to the requesting account
- [ ] Account enumeration is prevented (login and reset responses do not reveal valid usernames)
- [ ] Logout invalidates the session server-side (not just clearing the client cookie)
- [ ] CORS configuration does not allow arbitrary origins for authenticated endpoints
- [ ] Privilege escalation through parameter tampering (e.g., changing `role=admin`) is blocked
- [ ] Auth middleware cannot be bypassed by routing directly to handler functions

## Code Examples

Insecure -- storing JWT in localStorage:

```typescript
// BAD: Accessible to XSS attacks
localStorage.setItem("token", jwt);
```

Secure -- using HttpOnly cookie:

```typescript
// GOOD: Not accessible to JavaScript
res.setHeader("Set-Cookie", serialize("token", jwt, {
  httpOnly: true,
  secure: true,
  sameSite: "strict",
  path: "/",
  maxAge: 900,
}));
```

Insecure -- missing server-side authorization:

```typescript
// BAD: Relies on client-side role check only
if (user.role === "admin") {
  return <AdminPanel />;
}
```

Secure -- server-side authorization enforcement:

```typescript
// GOOD: Server validates authorization on every request
export async function GET(req: Request) {
  const session = await getServerSession(authOptions);
  if (!session || session.user.role !== "admin") {
    return new Response("Forbidden", { status: 403 });
  }
  return NextResponse.json(await getAdminData());
}
```
